

******************************
From build perspective:
******************************


1) table68k
	- pre existing manually produced text file
	
	0000 0000 0011 1100:00:XNZVC:XNZVC:10: ORSR.B  #1
	0000 0000 0111 1100:02:?????:?????:10: ORSR.W  #1


Phase 2: generate cpudefs


2) build68k      	-> .c into .exe    						build the needed tool to convert table68k into cpudefs.c

2.1) cpudefs.c		-> build68k gets parameter pointing to table68			generates compiler usable defs68k array of isntruction definitions

	#include "sysconfig.h"
	#include "sysdeps.h"
	#include "readcpu.h"
	struct instr_def defs68k[] = {
	{ 60, 0, {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}, 65535, 0, 0, { { 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }  }, 16, "ORSR.B  #1"},
	---
	int n_defs68k = 179;					<-- totalling of this amount of (really implemented) instructions


2.2) build: gencpu			-> gencpu.o readcpu.o cpudefs.o			build the needed tool to generate cpuemu.c
2.3) build: gencomp			-> gencomp.o readcpu.o cpudefs.o		build the needed tool to generate compemu.c




--------------------------------------------------------------------------------------------------------
How do gencpu ja gencomp get called from Makefile:


OBJS = main.o cpudefs.o cpustbl.o  @JITOBJS@

cpudefs.c: tools/build68k @top_srcdir@/src/table68k
	./tools/build68k <@top_srcdir@/src/table68k >cpudefs.c

cpuemu.c: tools/gencpu
	./tools/gencpu

compemu.c: tools/gencomp
	./tools/gencomp

# gencpu also creates cpustbl.c and cputbl.h
cpustbl.c: cpuemu.c
cputbl.h: cpuemu.c
compstbl.c: compemu.c
comptbl.h: compemu.c


--> so from OBJ: cpustbl.o		--> requires cpuemu.c			--> requires ./tools/gencpu to be executed


same is with JIT objects:

@JITOBJS@

JITOBJS=""
if [ "x$WANT_JIT" = "xyes" ]; then
  JITOBJS="compstbl.o compemu.o compemu_support.o compemu_fpp.o cpustbl_nf.o cpufast_nf.o"
  ADDITIONAL_CFLAGS="$ADDITIONAL_CFLAGS -DJIT -DNATMEM_OFFSET=0x50000000"
fi

--> so from OBJ: compstbl.o		--> requires compstbl.c			--> requires ./tools/gencomp to be executed

---------------------------------------------------------------------------------------------------------


Phase 3: generate cpu-emu and comp-emu codes:

3.1) call: gencpu									generates cpuemu.c     and cpustbl.c and cputbl.h

3.2) call: gencomp									generates compemu.c    and compstbl.c comptbl.h


---------------------------------------------------------------------------------------------------------



******************************
From code perspective:
******************************


**********************************************
Initializing instructions (Phases 1 - 2):
**********************************************


build68k.c

/*
 * Read 68000 CPU specs from file "table68k" and build cpudefs.c
 */

int main(int argc, char **argv)
{
    int no_insns = 0;

    printf ("#include \"sysconfig.h\"\n");
    printf ("#include \"sysdeps.h\"\n");
    printf ("#include \"readcpu.h\"\n");
    printf ("struct instr_def defs68k[] = {\n");		<-- stdout to cpudefs.c file
	
    tablef = stdin;						<-- stdin from table68k file
	



cpudefs.c							<-- build68k outputted this file as its stdout

#include "sysconfig.h"
#include "sysdeps.h"
#include "readcpu.h"
struct instr_def defs68k[] = {							<-- array of instructions (readcpu.h)
{ 60, 0, {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}, 65535, 0, 0, { { 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }  }, 16, "ORSR.B  #1"},
---
int n_defs68k = 179;								<-- size of that array 



readcpu.h

struct instr_def {						<-- individual values (defs68k array) are stored using this
    unsigned int bits;
    int n_variable;
    char bitpos[16];
    unsigned int mask;
    int cpulevel;
    int plevel;
    struct {
	unsigned int flaguse:3;
	unsigned int flagset:3;
    } flaginfo[5];
    unsigned char sduse;
    const char *opcstr;
};



*********************************************************
Generating actual opcodes from instructions (Phase 3)
*********************************************************


readcpu.h

extern struct instr {					<-- using this structure create instructions
    long int handler;
    unsigned char dreg;
    unsigned char sreg;
    signed char dpos;
    signed char spos;
    unsigned char sduse;
    int flagdead:8, flaglive:8;
    unsigned int mnemo:8;;
    unsigned int cc:4;
    unsigned int plev:2;
    unsigned int size:2;
    unsigned int smode:5;
    unsigned int stype:3;
    unsigned int dmode:5;
    unsigned int suse:1;
    unsigned int duse:1;
    unsigned int unused1:1;
    unsigned int clev:3;
    unsigned int isjmp:1;
    unsigned int unused2:4;
} *table68k;


readcpu.c

struct instr *table68k;									<-- table68k as a pointer is here




gencomp.c										<-- JIT code compiler generator

void read_table68k (void)
{
    int i;

    table68k = (struct instr *)xmalloc (65536 * sizeof (struct instr));			<-- allocate table68k memory
    for (i = 0; i < 65536; i++) {
	table68k[i].mnemo = i_ILLG;
	table68k[i].handler = -1;
    }
    for (i = 0; i < n_defs68k; i++) {
	build_insn (i);
    }
}


static void build_insn (int insn)
{
    int find = -1;
    int variants;
    int isjmp = 0;
    struct instr_def id;
    const char *opcstr;
    int i;

    int flaglive = 0, flagdead = 0;

    id = defs68k[insn];									<-- table from cpudefs.c
	
	---
	table68k[opc].size = sz;							<-- fill all rest of table68k fields	
	table68k[opc].sreg = srcreg;
	table68k[opc].dreg = destreg;
	table68k[opc].smode = srcmode;
	table68k[opc].dmode = destmode;
	table68k[opc].spos = srcgather ? srcpos : -1;
	table68k[opc].dpos = dstgather ? dstpos : -1;
	table68k[opc].suse = usesrc;
	table68k[opc].duse = usedst;
	table68k[opc].stype = srctype;
	table68k[opc].plev = id.plevel;
	table68k[opc].clev = id.cpulevel;
	table68k[opc].flagdead = flagdead;
	table68k[opc].flaglive = flaglive;
	table68k[opc].isjmp = isjmp;
	---



int
main (int argc, char **argv)
{
    read_table68k ();									<-- defs68k[] conversion to table68k[]
    do_merges ();									<-- byte / word ie. versions = same instruction in table68k

    opcode_map = (int *) xmalloc (sizeof (int) * nr_cpuop_funcs);
    opcode_last_postfix = (int *) xmalloc (sizeof (int) * nr_cpuop_funcs);
    opcode_next_clev = (int *) xmalloc (sizeof (int) * nr_cpuop_funcs);
    counts = (unsigned long *) xmalloc (65536 * sizeof (unsigned long));
    read_counts ();

    /* It would be a lot nicer to put all in one file (we'd also get rid of
     * cputbl.h that way), but cpuopti can't cope.  That could be fixed, but
     * I don't dare to touch the 68k version.  */

    headerfile = fopen ("comptbl.h", "wb");			<--  compiling table
    stblfile = fopen ("compstbl.c", "wb");			<--  compiling source table
    freopen ("compemu.c", "wb", stdout);			<--  compemu.c will be stdout as a file

    generate_includes (stdout);
    generate_includes (stblfile);

    printf("#include \"compemu.h\"\n");							<-- std-out to compemu.c

    noflags=0;										<-- op_smalltbl_%d_comp_ff
	generate_func (noflags);		

    opcode_map = (int *) xmalloc (sizeof (int) * nr_cpuop_funcs);
    opcode_last_postfix = (int *) xmalloc (sizeof (int) * nr_cpuop_funcs);
    opcode_next_clev = (int *) xmalloc (sizeof (int) * nr_cpuop_funcs);
    counts = (unsigned long *) xmalloc (65536 * sizeof (unsigned long));
    read_counts ();
    noflags=1;										<-- op_smalltbl_%d_comp_nf
    generate_func (noflags);
	
	
	
static void
generate_func (int noflags)
{
    int i, j, rp;

	if (noflags)
	    fprintf (stblfile, "struct cputbl op_smalltbl_%d_comp_nf[] = {\n", postfix);
	else
	    fprintf (stblfile, "struct cputbl op_smalltbl_%d_comp_ff[] = {\n", postfix);

	---	
	generate_one_opcode (rp,noflags);




static void
generate_one_opcode (int rp, int noflags)
{

    aborted=gen_opcode (opcode);




static int  /* returns zero for success, non-zero for failure */
gen_opcode (unsigned long int opcode)
{
	---
	switch (curi->mnemo)					<-- different opcodes
	{
	  case i_OR:
	  case i_AND:
	  case i_EOR:





*************************************************************************************************************************

Result files:


comptbl.h										<-- gencomp.c stdout printed

extern cpuop_func op_0_0_comp_ff;
extern cpuop_func op_10_0_comp_ff;
extern cpuop_func op_18_0_comp_ff;
extern cpuop_func op_20_0_comp_ff;
extern cpuop_func op_28_0_comp_ff;
extern cpuop_func op_30_0_comp_ff;



compstbl.c										<-- gencomp.c stdout printed

struct cputbl op_smalltbl_0_comp_ff[] = {
{ op_0_0_comp_ff, 0x00000002, 0 }, /* OR */
{ op_10_0_comp_ff, 0x00000002, 16 }, /* OR */
{ op_18_0_comp_ff, 0x00000002, 24 }, /* OR */
{ op_20_0_comp_ff, 0x00000002, 32 }, /* OR */
{ op_28_0_comp_ff, 0x00000002, 40 }, /* OR */
{ op_30_0_comp_ff, 0x00000002, 48 }, /* OR */
{ op_38_0_comp_ff, 0x00000002, 56 }, /* OR */
{ op_39_0_comp_ff, 0x00000002, 57 }, /* OR */
---


compemu.c										<-- gencomp.c stdout printed opcodes


unsigned long REGPARAM2 op_0_0_comp_ff(uae_u32 opcode) /* OR */
{
	uae_u32 dstreg = opcode & 7;
	uae_u32 dodgy=0;
	uae_u32 m68k_pc_offset_thisinst=m68k_pc_offset;
	m68k_pc_offset+=2;
{	uae_u8 scratchie=S1;
{	int src = scratchie++;
	mov_l_ri(src,(uae_s32)(uae_s8)comp_get_ibyte((m68k_pc_offset+=2)-2));
{	int dst=dstreg;
	dont_care_flags();
{	start_needflags();
	or_b(dst,src);
	live_flags();
	end_needflags();
}	if(dstreg!=dst)
		mov_b_rr(dstreg,dst);
}}}	 if (m68k_pc_offset>100) sync_m68k_pc();
return 0;
}


also:

compemu.h					<--- manually prepared header for previous



*************************************************************************************************************************
How all of that works (= the idea) :


gencomp.c					Will std-out ALL OPCODES that then use real functions from compemu_support.c


static void
genmovemel (uae_u16 opcode)
{
    comprintf ("\tuae_u16 mask = %s;\n", gen_nextiword ());
    comprintf ("\tint native=scratchie++;\n");
    comprintf ("\tint i;\n");
    comprintf ("\tsigned char offset=0;\n");
    genamode (table68k[opcode].dmode, "dstreg", table68k[opcode].size, "src", 2, 1);
    comprintf("\tget_n_addr(srca,native,scratchie);\n");

    comprintf("\tfor (i=0;i<16;i++) {\n"
	      "\t\tif ((mask>>i)&1) {\n");
    switch(table68k[opcode].size) {
     case sz_long:
	comprintf("\t\t\tmov_l_rR(i,native,offset);\n"
		  "\t\t\tbswap_32(i);\n"
		  "\t\t\toffset+=4;\n");
	break;
     case sz_word:
	comprintf("\t\t\tmov_w_rR(i,native,offset);\n"
		  "\t\t\tbswap_16(i);\n"
		  "\t\t\tsign_extend_16_rr(i,i);\n"
		  "\t\t\toffset+=2;\n");
	break;
     default: abort();
    }
    comprintf("\t\t}\n"
	      "\t}");
    if (table68k[opcode].dmode == Aipi) {
	comprintf("\t\t\tlea_l_brr(8+dstreg,srca,offset);\n");
    }
}



compemu_support.c			All (std-outted) opcodes will use these functions internally

MENDFUNC(3, mov_l_rR, (W4 d, R4 s, IMM offset))
	/* read the word at the address contained in s+offset and store in d */
	MIDFUNC(3, mov_w_rR, (W2 d, R4 s, IMM offset))
{
	if (isconst(s))
	{
		COMPCALL(mov_w_rm) (d, live.state[s].val + offset);
		return;
	}
	CLOBBER_MOV;
	s = readreg(s, 4);
	d = writereg(d, 2);

	raw_mov_w_rR(d, s, offset);
	unlock2(d);
	unlock2(s);
}


MENDFUNC(2, mov_w_rm, (W2 d, IMM s)) MIDFUNC(2, mov_b_mr, (IMM d, R1 s))
{
	if (isconst(s))
	{
		COMPCALL(mov_b_mi) (d, (uae_u8) live.state[s].val);
		return;
	}

	CLOBBER_MOV;
	s = readreg(s, 1);

	raw_mov_b_mr(d, s);
	unlock2(s);
}



compemu.c				All op-codes implementation (using compemu_support.c)

op_xxxx_x_comp_ff      			All opcodes functions (look above f.ex. unsigned long REGPARAM2 op_0_0_comp_ff(uae_u32 opcode) /* OR */)



comptbl.h				extern definitions for all opcodes

extern cpuop_func op_0_0_comp_ff;




compstbl.c				table definition for all opcodes, using cputbl structure:

struct cputbl op_smalltbl_0_comp_ff[] = {
{ op_0_0_comp_ff, 0x00000002, 0 }, /* OR */


----------------------------------
newcpu.h

struct cputbl {
    cpuop_func *handler;
    int specific;
    uae_u32 opcode;
};

----------------------------------

compemu.h

DECLARE(mov_l_rR(W4 d, R4 s, IMM offset));
	"extern void mov_l_rR(..."		all compemu_support.c functions as extern





Starting to JIT compiler with all of above:


#include "comptbl.h"
#include "compemu.h"


cpuop_func *compfunctbl[65536];				<-- compiler function table
cpuop_func *nfcompfunctbl[65536];			<-- compiler function table .. no flags
cpuop_func *nfcpufunctbl[65536];			<-- cpu function table, no flags, in case no compiler possible


--------------------------------------------------------------
newcpu.h

typedef unsigned long cpuop_func (uae_u32) REGPARAM;


compemu.h

typedef struct {
    uae_u8 use_flags;
    uae_u8 set_flags;
    uae_u8 is_jump;
    uae_u8 is_addx;
    uae_u8 is_const_jump;
} op_properties;
extern op_properties prop[65536];

--------------------------------------------------------------


void
build_comp(void)
{
	int i;
	int jumpcount = 0;
	unsigned long opcode;
	struct cputbl *tbl = op_smalltbl_0_comp_ff;							<-- compiler generated codes table
	struct cputbl *nftbl = op_smalltbl_0_comp_nf;						<-- compiler generated codes table .. no flags
	int count;
	struct cputbl *nfctbl = (currprefs.cpu_level == 4 ? op_smalltbl_0_nf			<-- cpu generated codes table
		: currprefs.cpu_level == 3 ? op_smalltbl_1_nf
		: currprefs.cpu_level == 2 ? op_smalltbl_2_nf
		: currprefs.cpu_level == 1 ? op_smalltbl_3_nf
		: !currprefs.cpu_compatible ? op_smalltbl_4_nf : op_smalltbl_5_nf);
	raw_init_cpu();
#ifdef NATMEM_OFFSET
	write_log("Setting signal handler\n");
	signal(SIGSEGV, vec);
#endif
	write_log("Building Compiler function table\n");
	for (opcode = 0; opcode < 65536; opcode++)							<-- initialized as illegal
	{
		nfcpufunctbl[opcode] = op_illg_1;
		compfunctbl[opcode] = NULL;
		nfcompfunctbl[opcode] = NULL;
		prop[opcode].use_flags = 0x1f;
		prop[opcode].set_flags = 0x1f;
		prop[opcode].is_jump = 1;
	}

	for (i = 0; tbl[i].opcode < 65536; i++)
	{
		int isjmp = (tbl[i].specific & 1);
		int isaddx = (tbl[i].specific & 8);
		int iscjmp = (tbl[i].specific & 16);

		prop[tbl[i].opcode].is_jump = isjmp;
		prop[tbl[i].opcode].is_const_jump = iscjmp;
		prop[tbl[i].opcode].is_addx = isaddx;
		compfunctbl[tbl[i].opcode] = tbl[i].handler;					<-- real comp function pointers
	}
	for (i = 0; nftbl[i].opcode < 65536; i++)
	{
		nfcompfunctbl[nftbl[i].opcode] = nftbl[i].handler;				<-- no flags comp function pointers
		nfcpufunctbl[nftbl[i].opcode] = nfctbl[i].handler;				<-- no flags cpu emulated function pointers
	}

	for (i = 0; nfctbl[i].handler; i++)
	{
		nfcpufunctbl[nfctbl[i].opcode] = nfctbl[i].handler;
	}

	for (opcode = 0; opcode < 65536; opcode++)
	{
		cpuop_func *f;
		cpuop_func *nff;
		cpuop_func *nfcf;
		int isjmp, isaddx, iscjmp;

		if (table68k[opcode].mnemo == i_ILLG || table68k[opcode].clev > currprefs.cpu_level)
			continue;

		if (table68k[opcode].handler != -1)
		{
			f = compfunctbl[table68k[opcode].handler];				<-- some comp functions are identical (generic implementation)
			nff = nfcompfunctbl[table68k[opcode].handler];
			nfcf = nfcpufunctbl[table68k[opcode].handler];
			isjmp = prop[table68k[opcode].handler].is_jump;
			iscjmp = prop[table68k[opcode].handler].is_const_jump;
			isaddx = prop[table68k[opcode].handler].is_addx;
			prop[opcode].is_jump = isjmp;
			prop[opcode].is_const_jump = iscjmp;
			prop[opcode].is_addx = isaddx;
			compfunctbl[opcode] = f;								<-- assign one to all of 65k opcodes
			nfcompfunctbl[opcode] = nff;
			Dif(nfcf == op_illg_1) abort();
			nfcpufunctbl[opcode] = nfcf;
		}
		prop[opcode].set_flags = table68k[opcode].flagdead;
		prop[opcode].use_flags = table68k[opcode].flaglive;
		/* Unconditional jumps don't evaluate condition codes, so they
		 * don't actually use any flags themselves */
		if (prop[opcode].is_const_jump)
			prop[opcode].use_flags = 0;
	}
	for (i = 0; nfctbl[i].handler != NULL; i++)
	{
		if (nfctbl[i].specific)
			nfcpufunctbl[tbl[i].opcode] = nfctbl[i].handler;
	}

	count = 0;
	for (opcode = 0; opcode < 65536; opcode++)
	{
		if (compfunctbl[opcode])
			count++;
	}
	write_log("Supposedly %d compileable opcodes!\n", count);

	/* Initialise state */
	create_popalls();
	alloc_cache();
	reset_lists();

	for (i = 0; i < TAGSIZE; i += 2)
	{
		cache_tags[i].handler = (void *) popall_execute_normal;
		cache_tags[i + 1].bi = NULL;
	}
	compemu_reset();

#if 0
	for (i = 0; i < N_REGS; i++)
	{
		empty_ss.nat[i].holds = -1;
		empty_ss.nat[i].validsize = 0;
		empty_ss.nat[i].dirtysize = 0;
	}
#endif
	for (i = 0; i < VREGS; i++)
	{
		empty_ss.virt[i] = L_NEEDED;
	}
	for (i = 0; i < N_REGS; i++)
	{
		empty_ss.nat[i] = L_UNKNOWN;
	}
	default_ss = empty_ss;
}


















